# Copyright 2022 Milan Vukov. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""" Implements an app for generation and export of 2D motion primitives.
"""
import argparse
import dataclasses
import os
from typing import List
from typing import Tuple

import numpy

from optimus.path_planning import geometry
from optimus.path_planning import primitive_generator


@dataclasses.dataclass(frozen=True)
class MotionPrimitive2D:
  """ Mirrors the C++ version in action_set_2d.h.
  """
  length: float
  abs_angle_diff: float
  x: numpy.ndarray
  y: numpy.ndarray
  theta: numpy.ndarray
  swath_x: numpy.ndarray
  swath_y: numpy.ndarray
  start_angle_idx: int
  end_angle_idx: int
  end_x_idx: int
  end_y_idx: int


def generate_motion_primitives_for_export(
    grid_connectivity: int, min_radius_grid: float,
    max_angle_idx_diff: int) -> Tuple[List[float], List[MotionPrimitive2D]]:
  angles = primitive_generator.get_angles(grid_connectivity)
  primitives = primitive_generator.generate_all_primitives(
      angles, min_radius_grid, max_angle_idx_diff)

  primitives_for_export = []
  for primitive in primitives:
    swath_xy = primitive_generator.compute_swath(primitive)
    swath_xy = primitive_generator.sort_row_wise(swath_xy)
    swath_x, swath_y = zip(*swath_xy)

    primitive_for_export = MotionPrimitive2D(
        length=primitive.length,
        abs_angle_diff=numpy.abs(
            geometry.get_angle_diff(primitive.theta[0], primitive.theta[-1])),
        x=primitive.x,
        y=primitive.y,
        theta=primitive.theta,
        swath_x=numpy.array(swath_x),
        swath_y=numpy.array(swath_y),
        start_angle_idx=primitive.start_angle_idx,
        end_x_idx=primitive_generator.to_grid_coord(primitive.x[-1]),
        end_y_idx=primitive_generator.to_grid_coord(primitive.y[-1]),
        end_angle_idx=primitive.end_angle_idx,
    )
    primitives_for_export.append(primitive_for_export)
  return numpy.asarray([el.angle for el in angles]), primitives_for_export


CPP_OUTPUT_TEMPLATE = """// This file is automatically generated.
#ifndef {header_guard}
#define {header_guard}

#include "optimus/path_planning/action_set_2d.h"

namespace optimus {{

static const ActionSet2D g_{action_set_name} = {{
  // Sorted primitive angles (-pi, pi].
  {angles},
  // primitive_group_start_indices
  {primitive_group_start_indices},
  // Motion primitives:
  {{
{primitives}
  }},
  // Per-angle-index predecessors
  {{
{predecessors}
  }},
  // Affected states by a grid value change at position x = 0, y = 0
  {{
{position_change_affected_states}
  }}
}};

const auto& get_{action_set_name}() {{ return g_{action_set_name}; }}

}}  // namespace optimus

#endif  // {header_guard}
"""

CPP_MOTION_PRIMITIVE_TEMPLATE = """{{
  // primitive {index}
  // swath_x
  {swath_x},
  // swath_y
  {swath_y},
  // length
  {length},
  // abs_angle_diff
  {abs_angle_diff},
  // end_x_idx
  {end_x_idx},
  // end_y_idx
  {end_y_idx},
  // end_angle_idx
  {end_angle_idx},
  // x
  {x},
  // y
  {y},
  // theta
  {theta},
}}"""


def export_motion_primitives(angles: numpy.ndarray,
                             motion_primitives: List[MotionPrimitive2D],
                             file_name: str) -> None:

  def export(value) -> str:
    if isinstance(value, numpy.ndarray):
      return f'{{{", ".join([str(el) for el in value])}}}'
    return f'{value}'

  def dump_motion_primitive(index: int, p: MotionPrimitive2D) -> str:
    return CPP_MOTION_PRIMITIVE_TEMPLATE.format(
        index=index,
        length=export(p.length),
        abs_angle_diff=export(p.abs_angle_diff),
        x=export(p.x),
        y=export(p.y),
        theta=export(p.theta),
        swath_x=export(p.swath_x),
        swath_y=export(p.swath_y),
        end_angle_idx=export(p.end_angle_idx),
        end_x_idx=export(p.end_x_idx),
        end_y_idx=export(p.end_y_idx))

  exported_primitives = []
  current_start_angle_idx = None
  visited_start_angle_indices = []
  num_angles = len(angles)
  primitive_group_start_indices = [-1] * num_angles
  for idx, p in enumerate(motion_primitives):
    exported_primitives.append(dump_motion_primitive(idx, p))
    start_angle_idx = p.start_angle_idx
    if current_start_angle_idx != start_angle_idx:
      assert start_angle_idx not in visited_start_angle_indices
      primitive_group_start_indices[start_angle_idx] = idx
      visited_start_angle_indices.append(start_angle_idx)
      current_start_angle_idx = start_angle_idx

  predecessors = []
  for angle_idx in range(num_angles):
    current_predecessors = [
        f'{{{-p.end_x_idx}, {-p.end_y_idx}, {p.start_angle_idx}}}'
        for p in motion_primitives
        if p.end_angle_idx == angle_idx
    ]
    current_predecessors_str = ', '.join(current_predecessors)
    predecessors.append(f'{{{current_predecessors_str}}}')

  # For a grid value change at (0, 0) calculate all affected poses (states).
  # If an action whose swath passes through (0, 0), the start pose of
  # that action is affected by the change at (0, 0).
  position_change_affected_states = set()
  for p in motion_primitives:
    p_swath_x = p.swath_x
    p_swath_y = p.swath_y
    abs_x_max = numpy.max(numpy.abs(p_swath_x))
    abs_y_max = numpy.max(numpy.abs(p_swath_y))

    for x_offset in range(-abs_x_max, abs_x_max + 1):
      for y_offset in range(-abs_y_max, abs_y_max + 1):
        if (0, 0) in zip(p_swath_x + x_offset, p_swath_y + y_offset):
          position_change_affected_states.add(
              (x_offset, y_offset, p.start_angle_idx))
  position_change_affected_states = sorted(
      list(position_change_affected_states), key=lambda s: (s[0], s[1], s[2]))
  position_change_affected_states_str = ', '.join(
      [f'{{{s[0]}, {s[1]}, {s[2]}}}' for s in position_change_affected_states])

  header_guard = file_name.upper()
  header_guard = ''.join([c if c.isalnum() else '_' for c in header_guard])
  action_set_name = os.path.splitext(os.path.basename(file_name))[0]

  output_content = CPP_OUTPUT_TEMPLATE.format(
      header_guard=header_guard,
      action_set_name=action_set_name,
      angles=export(angles),
      primitive_group_start_indices=export(
          numpy.asarray(primitive_group_start_indices)),
      primitives=',\n'.join(exported_primitives),
      predecessors=',\n'.join(predecessors),
      position_change_affected_states=position_change_affected_states_str,
  )
  with open(file_name, 'w', encoding='utf-8') as stream:
    stream.write(output_content)


def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('--grid_connectivity',
                      type=int,
                      default=16,
                      help='See primitive_generator.get_angles.')
  parser.add_argument('--min_radius_grid',
                      type=float,
                      default=2,
                      help='See primitive_generator.generate_all_primitives.')
  parser.add_argument('--max_angle_idx_diff',
                      type=int,
                      default=4,
                      help='See primitive_generator.generate_all_primitives.')
  parser.add_argument('--output', type=str)
  args = parser.parse_args()

  angles, motion_primitives = generate_motion_primitives_for_export(
      args.grid_connectivity, args.min_radius_grid, args.max_angle_idx_diff)
  export_motion_primitives(angles, motion_primitives, args.output)


if __name__ == '__main__':
  main()
